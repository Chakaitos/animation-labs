---
phase: 02-authentication-account
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lib/actions/auth.ts
  - app/auth/confirm/route.ts
  - app/(auth)/auth-error/page.tsx
autonomous: true

must_haves:
  truths:
    - "Server actions exist for signup, signin, signout, password reset, and password update"
    - "Email verification callback exchanges token_hash for session"
    - "Auth errors redirect to a dedicated error page"
  artifacts:
    - path: "lib/actions/auth.ts"
      provides: "Server Actions for all auth operations"
      exports: ["signUp", "signIn", "signOut", "resetPassword", "updatePassword", "changePassword"]
    - path: "app/auth/confirm/route.ts"
      provides: "Email verification callback endpoint"
      exports: ["GET"]
    - path: "app/(auth)/auth-error/page.tsx"
      provides: "Auth error page"
  key_links:
    - from: "lib/actions/auth.ts"
      to: "lib/supabase/server.ts"
      via: "createClient import"
      pattern: "import.*createClient.*supabase/server"
    - from: "app/auth/confirm/route.ts"
      to: "supabase.auth.verifyOtp"
      via: "token_hash verification"
      pattern: "verifyOtp.*token_hash"
---

<objective>
Create Server Actions for all authentication operations and the email verification callback endpoint.

Purpose: These Server Actions are the backend for all auth forms. The callback endpoint handles email verification links from Supabase (signup confirmation and password reset). Forms in later plans will call these actions.

Output: Server Actions file with 6 auth functions, callback route handler, auth error page.
</objective>

<execution_context>
@/Users/chakaitos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chakaitos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-account/02-RESEARCH.md

@lib/supabase/server.ts
</context>

<important_note>
**Route Protection Pattern:** This phase does NOT use middleware for route protection. The existing `proxy.ts` file from Phase 1 handles only session token refresh (per @supabase/ssr pattern).

Route protection is implemented via **inline getUser() checks** in each protected Server Component:
```typescript
const { data: { user }, error } = await supabase.auth.getUser()
if (error || !user) {
  redirect('/login')
}
```

This pattern is used in Plans 02-04 (dashboard) and 02-05 (account settings). See RESEARCH.md "Pattern 4: Protected Routes with getUser()" for details.
</important_note>

<tasks>

<task type="auto">
  <name>Task 1: Create Server Actions for authentication</name>
  <files>lib/actions/auth.ts</files>
  <action>
Create lib/actions/auth.ts with 'use server' directive:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import { headers } from 'next/headers'

// Helper to get site URL for redirects
async function getSiteUrl() {
  const headersList = await headers()
  const host = headersList.get('host') || 'localhost:3000'
  const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http'
  return `${protocol}://${host}`
}

export async function signUp(formData: FormData) {
  const supabase = await createClient()
  const siteUrl = await getSiteUrl()

  const { error } = await supabase.auth.signUp({
    email: formData.get('email') as string,
    password: formData.get('password') as string,
    options: {
      emailRedirectTo: `${siteUrl}/auth/confirm`,
    },
  })

  if (error) {
    return { error: error.message }
  }

  redirect('/verify-email')
}

export async function signIn(formData: FormData) {
  const supabase = await createClient()

  const { error } = await supabase.auth.signInWithPassword({
    email: formData.get('email') as string,
    password: formData.get('password') as string,
  })

  if (error) {
    return { error: 'Invalid email or password' }
  }

  redirect('/dashboard')
}

export async function signOut() {
  const supabase = await createClient()
  await supabase.auth.signOut()
  redirect('/login')
}

export async function resetPassword(formData: FormData) {
  const supabase = await createClient()
  const siteUrl = await getSiteUrl()
  const email = formData.get('email') as string

  // Note: resetPasswordForEmail doesn't error if email doesn't exist
  // This prevents email enumeration (security best practice)
  await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${siteUrl}/auth/confirm?next=/update-password`,
  })

  // Always return success to prevent email enumeration
  return { success: true }
}

export async function updatePassword(formData: FormData) {
  const supabase = await createClient()
  const password = formData.get('password') as string

  const { error } = await supabase.auth.updateUser({
    password,
  })

  if (error) {
    return { error: error.message }
  }

  redirect('/login?message=password-updated')
}

export async function changePassword(formData: FormData) {
  const supabase = await createClient()

  // First verify current password by attempting sign in
  const { data: { user } } = await supabase.auth.getUser()

  if (!user?.email) {
    return { error: 'Not authenticated' }
  }

  const currentPassword = formData.get('currentPassword') as string
  const newPassword = formData.get('newPassword') as string

  // Verify current password
  const { error: signInError } = await supabase.auth.signInWithPassword({
    email: user.email,
    password: currentPassword,
  })

  if (signInError) {
    return { error: 'Current password is incorrect' }
  }

  // Update to new password
  const { error: updateError } = await supabase.auth.updateUser({
    password: newPassword,
  })

  if (updateError) {
    return { error: updateError.message }
  }

  // Sign out all sessions (forces re-login on all devices per CONTEXT.md)
  await supabase.auth.signOut({ scope: 'global' })

  redirect('/login?message=password-changed')
}
```

Key implementation notes:
- getSiteUrl() dynamically builds URL from headers (works in dev and production)
- signIn returns generic error message to prevent user enumeration
- resetPassword always returns success (per CONTEXT.md decision)
- changePassword verifies current password before allowing update
- changePassword calls signOut with global scope to force re-login everywhere
  </action>
  <verify>
- `npx tsc --noEmit` passes
- File exports all 6 functions: signUp, signIn, signOut, resetPassword, updatePassword, changePassword
  </verify>
  <done>All 6 Server Actions created with proper error handling and security considerations</done>
</task>

<task type="auto">
  <name>Task 2: Create email verification callback and error page</name>
  <files>app/auth/confirm/route.ts, app/(auth)/auth-error/page.tsx</files>
  <action>
Create callback route at app/auth/confirm/route.ts:

```typescript
import { createClient } from '@/lib/supabase/server'
import { type EmailOtpType } from '@supabase/supabase-js'
import { NextResponse, type NextRequest } from 'next/server'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const token_hash = searchParams.get('token_hash')
  const type = searchParams.get('type') as EmailOtpType | null
  const next = searchParams.get('next') ?? '/dashboard'

  // Prevent open redirect attacks - only allow internal paths
  const redirectTo = next.startsWith('/') ? next : '/dashboard'

  if (token_hash && type) {
    const supabase = await createClient()

    const { error } = await supabase.auth.verifyOtp({
      type,
      token_hash,
    })

    if (!error) {
      return NextResponse.redirect(new URL(redirectTo, request.url))
    }
  }

  // Redirect to error page on failure
  return NextResponse.redirect(new URL('/auth-error?error=verification-failed', request.url))
}
```

Create error page at app/(auth)/auth-error/page.tsx:

```typescript
import Link from 'next/link'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'

interface AuthErrorPageProps {
  searchParams: Promise<{ error?: string }>
}

export default async function AuthErrorPage({ searchParams }: AuthErrorPageProps) {
  const params = await searchParams
  const error = params.error

  const errorMessages: Record<string, { title: string; description: string }> = {
    'verification-failed': {
      title: 'Verification Failed',
      description: 'The verification link is invalid or has expired. Please request a new one.',
    },
    default: {
      title: 'Authentication Error',
      description: 'Something went wrong. Please try again.',
    },
  }

  const { title, description } = errorMessages[error || 'default'] || errorMessages.default

  return (
    <div className="flex min-h-screen items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <CardTitle className="text-2xl text-destructive">{title}</CardTitle>
          <CardDescription>{description}</CardDescription>
        </CardHeader>
        <CardContent className="flex flex-col gap-4">
          <Button asChild>
            <Link href="/login">Back to Login</Link>
          </Button>
          <Button variant="outline" asChild>
            <Link href="/reset-password">Request New Reset Link</Link>
          </Button>
        </CardContent>
      </Card>
    </div>
  )
}
```

The callback route:
- Extracts token_hash and type from URL parameters
- Uses verifyOtp to exchange token for session
- Supports ?next parameter for redirect after verification
- Validates redirectTo to prevent open redirect attacks
- Falls back to /dashboard for successful verification
- Redirects to /auth-error on failure

Note: The Card component is installed in Plan 02-01 (added to shadcn component list).
  </action>
  <verify>
- `npx tsc --noEmit` passes
- app/auth/confirm/route.ts exports GET handler
- app/(auth)/auth-error/page.tsx renders error card
  </verify>
  <done>Callback endpoint exchanges token_hash for session, error page displays user-friendly messages</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Server Actions can be imported: `import { signUp, signIn } from '@/lib/actions/auth'`
3. Callback route exists at /auth/confirm
4. Error page renders at /auth-error
</verification>

<success_criteria>
- lib/actions/auth.ts exports 6 Server Actions
- app/auth/confirm/route.ts handles GET requests with token_hash verification
- app/(auth)/auth-error/page.tsx displays error messages
- All files pass TypeScript compilation
- `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-account/02-02-SUMMARY.md`
</output>
