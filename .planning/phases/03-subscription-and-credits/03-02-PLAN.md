---
phase: 03-subscription-and-credits
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - supabase/migrations/00002_webhook_events.sql
  - app/api/webhooks/stripe/route.ts
autonomous: true
user_setup:
  - service: supabase
    why: "Run migration to create webhook_events table"
    dashboard_config:
      - task: "Apply migration via Supabase Dashboard SQL Editor or CLI"
        location: "Supabase Dashboard -> SQL Editor"

must_haves:
  truths:
    - "Webhook endpoint verifies Stripe signature before processing"
    - "Duplicate webhook events are rejected (idempotency)"
    - "checkout.session.completed creates subscription with credits"
    - "customer.subscription.updated syncs status changes"
    - "customer.subscription.deleted marks subscription cancelled"
    - "invoice.payment_succeeded resets credits on renewal"
  artifacts:
    - path: "app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler"
      exports: ["POST"]
    - path: "supabase/migrations/00002_webhook_events.sql"
      provides: "Webhook idempotency table"
      contains: "CREATE TABLE webhook_events"
  key_links:
    - from: "app/api/webhooks/stripe/route.ts"
      to: "stripe.webhooks.constructEvent"
      via: "signature verification"
      pattern: "constructEvent.*signature"
    - from: "app/api/webhooks/stripe/route.ts"
      to: "webhook_events table"
      via: "idempotency check"
      pattern: "webhook_events.*stripe_event_id"
    - from: "app/api/webhooks/stripe/route.ts"
      to: "subscriptions table"
      via: "Supabase service role client"
      pattern: "supabase.*from.*subscriptions"
---

<objective>
Create Stripe webhook handler with signature verification and idempotency protection

Purpose: Sync Stripe subscription state to Supabase - the source of truth for billing
Output: Webhook route handler and database migration for event tracking
</objective>

<execution_context>
@/Users/chakaitos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chakaitos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-subscription-and-credits/03-RESEARCH.md
@supabase/migrations/00001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook events migration</name>
  <files>supabase/migrations/00002_webhook_events.sql</files>
  <action>
Create `supabase/migrations/00002_webhook_events.sql`:
```sql
-- Webhook Events Table
-- Tracks processed Stripe webhook events for idempotency
-- Prevents duplicate processing when Stripe retries webhooks

CREATE TABLE public.webhook_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  stripe_event_id TEXT UNIQUE NOT NULL,
  event_type TEXT NOT NULL,
  processed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  payload JSONB
);

COMMENT ON TABLE public.webhook_events IS 'Tracks processed Stripe webhooks for idempotency';
COMMENT ON COLUMN public.webhook_events.stripe_event_id IS 'Unique Stripe event ID (evt_...)';
COMMENT ON COLUMN public.webhook_events.payload IS 'Original event payload for debugging';

-- Index for quick lookup by Stripe event ID
CREATE INDEX webhook_events_stripe_id_idx ON public.webhook_events(stripe_event_id);

-- Index for cleanup queries (delete old events)
CREATE INDEX webhook_events_processed_at_idx ON public.webhook_events(processed_at);

-- No RLS needed - table is only accessed by service role from webhook handler
-- Users cannot access webhook events

-- Add overage_credits column to subscriptions table
-- Overage credits persist across billing periods (unlike subscription credits)
ALTER TABLE public.subscriptions
ADD COLUMN overage_credits INT NOT NULL DEFAULT 0 CHECK (overage_credits >= 0);

COMMENT ON COLUMN public.subscriptions.overage_credits IS 'Purchased credits that persist across billing periods';

-- Update deduct_credits function to use overage credits first
CREATE OR REPLACE FUNCTION public.deduct_credits(
  p_user_id UUID,
  p_video_id UUID,
  p_credits INT DEFAULT 1,
  p_description TEXT DEFAULT 'Video creation'
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_subscription_id UUID;
  v_credits_remaining INT;
  v_overage_credits INT;
  v_from_overage INT;
  v_from_subscription INT;
BEGIN
  -- Get active subscription
  SELECT id, credits_remaining, overage_credits
  INTO v_subscription_id, v_credits_remaining, v_overage_credits
  FROM public.subscriptions
  WHERE user_id = p_user_id
    AND status = 'active'
    AND (current_period_end IS NULL OR current_period_end > NOW())
  ORDER BY created_at DESC
  LIMIT 1
  FOR UPDATE; -- Lock the row

  IF v_subscription_id IS NULL THEN
    RETURN FALSE;
  END IF;

  -- Check total credits available
  IF (v_credits_remaining + v_overage_credits) < p_credits THEN
    RETURN FALSE;
  END IF;

  -- Deduct from overage first, then subscription
  IF v_overage_credits >= p_credits THEN
    v_from_overage := p_credits;
    v_from_subscription := 0;
  ELSE
    v_from_overage := v_overage_credits;
    v_from_subscription := p_credits - v_overage_credits;
  END IF;

  -- Update credits
  UPDATE public.subscriptions
  SET credits_remaining = credits_remaining - v_from_subscription,
      overage_credits = overage_credits - v_from_overage
  WHERE id = v_subscription_id;

  -- Record transaction with source info
  INSERT INTO public.credit_transactions (user_id, subscription_id, video_id, amount, type, description)
  VALUES (p_user_id, v_subscription_id, p_video_id, -p_credits, 'usage',
    CASE
      WHEN v_from_overage > 0 AND v_from_subscription > 0 THEN
        p_description || ' (' || v_from_overage || ' overage + ' || v_from_subscription || ' subscription)'
      WHEN v_from_overage > 0 THEN
        p_description || ' (overage credits)'
      ELSE
        p_description || ' (subscription credits)'
    END
  );

  RETURN TRUE;
END;
$$;

-- Update check_credits to include overage credits
CREATE OR REPLACE FUNCTION public.check_credits(p_user_id UUID, p_required INT DEFAULT 1)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total_credits INT;
BEGIN
  SELECT COALESCE(credits_remaining, 0) + COALESCE(overage_credits, 0) INTO v_total_credits
  FROM public.subscriptions
  WHERE user_id = p_user_id
    AND status = 'active'
    AND (current_period_end IS NULL OR current_period_end > NOW())
  ORDER BY created_at DESC
  LIMIT 1;

  RETURN COALESCE(v_total_credits, 0) >= p_required;
END;
$$;
```

This migration:
1. Creates webhook_events table for idempotency
2. Adds overage_credits column to subscriptions
3. Updates deduct_credits() to use overage first
4. Updates check_credits() to include overage
  </action>
  <verify>
File exists at supabase/migrations/00002_webhook_events.sql with valid SQL syntax.
  </verify>
  <done>Migration file created with webhook_events table and overage credit support</done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe webhook route handler</name>
  <files>app/api/webhooks/stripe/route.ts</files>
  <action>
Create `app/api/webhooks/stripe/route.ts`:
```typescript
import { stripe } from '@/lib/stripe/client'
import { PLANS, getPlanByPriceId, getCreditPackByPriceId, CREDIT_PACKS } from '@/lib/stripe/config'
import { createClient } from '@supabase/supabase-js'
import { NextRequest, NextResponse } from 'next/server'
import Stripe from 'stripe'

// Use service role key to bypass RLS - webhook needs full database access
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export async function POST(req: NextRequest) {
  const body = await req.text() // CRITICAL: Must use .text(), not .json()
  const signature = req.headers.get('stripe-signature')

  if (!signature) {
    console.error('Missing Stripe signature header')
    return NextResponse.json({ error: 'Missing signature' }, { status: 400 })
  }

  let event: Stripe.Event
  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    )
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error'
    console.error('Webhook signature verification failed:', message)
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })
  }

  // Idempotency check - prevent duplicate processing
  const { data: existing } = await supabase
    .from('webhook_events')
    .select('id')
    .eq('stripe_event_id', event.id)
    .single()

  if (existing) {
    console.log(`Event ${event.id} already processed, skipping`)
    return NextResponse.json({ received: true })
  }

  console.log(`Processing webhook: ${event.type} (${event.id})`)

  try {
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as Stripe.Checkout.Session
        await handleCheckoutCompleted(session)
        break
      }

      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription
        await handleSubscriptionUpdated(subscription)
        break
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription
        await handleSubscriptionDeleted(subscription)
        break
      }

      case 'invoice.payment_succeeded': {
        const invoice = event.data.object as Stripe.Invoice
        await handlePaymentSucceeded(invoice)
        break
      }

      case 'invoice.payment_failed': {
        const invoice = event.data.object as Stripe.Invoice
        await handlePaymentFailed(invoice)
        break
      }

      default:
        console.log(`Unhandled event type: ${event.type}`)
    }

    // Log event to prevent duplicate processing
    await supabase.from('webhook_events').insert({
      stripe_event_id: event.id,
      event_type: event.type,
      payload: event.data.object,
    })

    return NextResponse.json({ received: true })
  } catch (error) {
    console.error(`Error processing webhook ${event.type}:`, error)
    // Return 500 so Stripe will retry
    return NextResponse.json({ error: 'Processing failed' }, { status: 500 })
  }
}

async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const userId = session.metadata?.user_id
  if (!userId) {
    console.error('No user_id in checkout session metadata')
    return
  }

  // Handle subscription checkout
  if (session.mode === 'subscription' && session.subscription) {
    const subscriptionId = typeof session.subscription === 'string'
      ? session.subscription
      : session.subscription.id

    // Get subscription details from Stripe
    const subscription = await stripe.subscriptions.retrieve(subscriptionId)
    const priceId = subscription.items.data[0]?.price.id
    const planId = priceId ? getPlanByPriceId(priceId) : null
    const plan = planId ? PLANS[planId] : null

    if (!plan || !planId) {
      console.error('Unknown price ID:', priceId)
      return
    }

    // Check if user already has a subscription
    const { data: existingSub } = await supabase
      .from('subscriptions')
      .select('id')
      .eq('user_id', userId)
      .single()

    if (existingSub) {
      // Update existing subscription
      await supabase
        .from('subscriptions')
        .update({
          plan: planId,
          status: 'active',
          credits_remaining: plan.credits,
          credits_total: plan.credits,
          stripe_customer_id: session.customer as string,
          stripe_subscription_id: subscriptionId,
          current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
          current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
        })
        .eq('id', existingSub.id)

      // Log credit grant
      await supabase.from('credit_transactions').insert({
        user_id: userId,
        subscription_id: existingSub.id,
        amount: plan.credits,
        type: 'subscription',
        description: `${plan.name} plan subscription activated`,
      })
    } else {
      // Create new subscription
      const { data: newSub } = await supabase
        .from('subscriptions')
        .insert({
          user_id: userId,
          plan: planId,
          status: 'active',
          credits_remaining: plan.credits,
          credits_total: plan.credits,
          stripe_customer_id: session.customer as string,
          stripe_subscription_id: subscriptionId,
          current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
          current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
        })
        .select('id')
        .single()

      if (newSub) {
        // Log credit grant
        await supabase.from('credit_transactions').insert({
          user_id: userId,
          subscription_id: newSub.id,
          amount: plan.credits,
          type: 'subscription',
          description: `${plan.name} plan subscription started`,
        })
      }
    }

    console.log(`Subscription created for user ${userId}: ${planId} (${plan.credits} credits)`)
  }

  // Handle one-time credit pack purchase
  if (session.mode === 'payment') {
    const lineItems = await stripe.checkout.sessions.listLineItems(session.id)
    const priceId = lineItems.data[0]?.price?.id
    const packId = priceId ? getCreditPackByPriceId(priceId) : null
    const pack = packId ? CREDIT_PACKS[packId] : null

    if (pack) {
      // Get user's subscription to add overage credits
      const { data: sub } = await supabase
        .from('subscriptions')
        .select('id')
        .eq('user_id', userId)
        .single()

      if (sub) {
        // Add overage credits
        await supabase
          .from('subscriptions')
          .update({
            overage_credits: supabase.rpc('get_overage_credits', { sub_id: sub.id }) // Will handle in another way
          })
          .eq('id', sub.id)

        // Actually, use raw SQL increment
        await supabase.rpc('add_overage_credits', {
          p_subscription_id: sub.id,
          p_credits: pack.credits,
        })

        // Log credit grant
        await supabase.from('credit_transactions').insert({
          user_id: userId,
          subscription_id: sub.id,
          amount: pack.credits,
          type: 'purchase',
          description: `Purchased ${pack.name} credit pack`,
        })

        console.log(`Credit pack purchased for user ${userId}: ${pack.credits} credits`)
      }
    }
  }
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  const priceId = subscription.items.data[0]?.price.id
  const planId = priceId ? getPlanByPriceId(priceId) : null

  await supabase
    .from('subscriptions')
    .update({
      status: subscription.status === 'active' ? 'active' :
              subscription.status === 'past_due' ? 'past_due' :
              subscription.status === 'canceled' ? 'cancelled' : 'active',
      plan: planId || undefined,
      current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
      current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
    })
    .eq('stripe_subscription_id', subscription.id)

  console.log(`Subscription updated: ${subscription.id} -> ${subscription.status}`)
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  await supabase
    .from('subscriptions')
    .update({ status: 'cancelled' })
    .eq('stripe_subscription_id', subscription.id)

  console.log(`Subscription cancelled: ${subscription.id}`)
}

async function handlePaymentSucceeded(invoice: Stripe.Invoice) {
  // Only reset credits for subscription renewals (not initial purchase)
  if (invoice.billing_reason !== 'subscription_cycle') {
    return
  }

  const subscriptionId = typeof invoice.subscription === 'string'
    ? invoice.subscription
    : invoice.subscription?.id

  if (!subscriptionId) return

  // Get subscription from Stripe to find plan
  const subscription = await stripe.subscriptions.retrieve(subscriptionId)
  const priceId = subscription.items.data[0]?.price.id
  const planId = priceId ? getPlanByPriceId(priceId) : null
  const plan = planId ? PLANS[planId] : null

  if (!plan) return

  // Get our subscription record
  const { data: sub } = await supabase
    .from('subscriptions')
    .select('id, user_id')
    .eq('stripe_subscription_id', subscriptionId)
    .single()

  if (!sub) return

  // Reset subscription credits (overage credits persist)
  await supabase
    .from('subscriptions')
    .update({
      credits_remaining: plan.credits,
      credits_total: plan.credits,
      current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
      current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
    })
    .eq('id', sub.id)

  // Log renewal
  await supabase.from('credit_transactions').insert({
    user_id: sub.user_id,
    subscription_id: sub.id,
    amount: plan.credits,
    type: 'subscription',
    description: `${plan.name} plan renewed - credits reset`,
  })

  console.log(`Subscription renewed: ${subscriptionId} (${plan.credits} credits reset)`)
}

async function handlePaymentFailed(invoice: Stripe.Invoice) {
  const subscriptionId = typeof invoice.subscription === 'string'
    ? invoice.subscription
    : invoice.subscription?.id

  if (!subscriptionId) return

  await supabase
    .from('subscriptions')
    .update({ status: 'past_due' })
    .eq('stripe_subscription_id', subscriptionId)

  console.log(`Payment failed for subscription: ${subscriptionId}`)
}
```

Note: The credit pack handling uses a simplified approach. We need to add an RPC function for adding overage credits.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. File exists at app/api/webhooks/stripe/route.ts
3. Exports POST function
  </verify>
  <done>Webhook handler processes checkout.session.completed, subscription updates, and invoice events with idempotency protection</done>
</task>

<task type="auto">
  <name>Task 3: Add overage credits RPC function to migration</name>
  <files>supabase/migrations/00002_webhook_events.sql</files>
  <action>
Append to the existing migration file (supabase/migrations/00002_webhook_events.sql):
```sql
-- Function to add overage credits (used by webhook for credit pack purchases)
CREATE OR REPLACE FUNCTION public.add_overage_credits(
  p_subscription_id UUID,
  p_credits INT
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.subscriptions
  SET overage_credits = overage_credits + p_credits
  WHERE id = p_subscription_id;
END;
$$;
```

This function allows the webhook handler to atomically increment overage credits.
  </action>
  <verify>
File contains add_overage_credits function definition.
  </verify>
  <done>Migration includes add_overage_credits RPC function for atomic credit pack additions</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- TypeScript compilation passes for webhook route
- Migration file contains valid SQL syntax
- Webhook handler imports stripe client and config correctly
</verification>

<success_criteria>
1. Migration creates webhook_events table with stripe_event_id unique constraint
2. Migration adds overage_credits column to subscriptions
3. Updated deduct_credits and check_credits functions handle overage credits
4. Webhook handler verifies Stripe signatures using raw body
5. Webhook handler checks idempotency before processing
6. All subscription lifecycle events handled (created, updated, deleted, renewed, failed)
7. Credit transactions logged for all credit grants
</success_criteria>

<output>
After completion, create `.planning/phases/03-subscription-and-credits/03-02-SUMMARY.md`
</output>
