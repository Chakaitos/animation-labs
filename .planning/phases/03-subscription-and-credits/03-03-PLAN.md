---
phase: 03-subscription-and-credits
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - lib/actions/checkout.ts
  - lib/actions/billing.ts
autonomous: true

must_haves:
  truths:
    - "User can create checkout session for subscription"
    - "User can create checkout session for credit pack"
    - "User can access Customer Portal for subscription management"
    - "Checkout redirects include user_id in metadata"
  artifacts:
    - path: "lib/actions/checkout.ts"
      provides: "Checkout session Server Actions"
      exports: ["createSubscriptionCheckout", "createCreditPackCheckout"]
    - path: "lib/actions/billing.ts"
      provides: "Billing management Server Actions"
      exports: ["createPortalSession", "getSubscription", "getCreditBalance"]
  key_links:
    - from: "lib/actions/checkout.ts"
      to: "stripe.checkout.sessions.create"
      via: "Stripe SDK"
      pattern: "checkout\\.sessions\\.create"
    - from: "lib/actions/checkout.ts"
      to: "session.metadata.user_id"
      via: "metadata attachment"
      pattern: "metadata.*user_id"
    - from: "lib/actions/billing.ts"
      to: "stripe.billingPortal.sessions.create"
      via: "Stripe SDK"
      pattern: "billingPortal\\.sessions\\.create"
---

<objective>
Create Server Actions for checkout and billing management

Purpose: Enable users to subscribe, purchase credits, and manage their subscription
Output: Server Actions for checkout sessions and Customer Portal access
</objective>

<execution_context>
@/Users/chakaitos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chakaitos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-subscription-and-credits/03-RESEARCH.md
@lib/actions/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create checkout Server Actions</name>
  <files>lib/actions/checkout.ts</files>
  <action>
Create `lib/actions/checkout.ts` following the established Server Actions pattern from auth.ts:
```typescript
'use server'

import { stripe } from '@/lib/stripe/client'
import { PLANS, CREDIT_PACKS, type PlanId, type CreditPackId } from '@/lib/stripe/config'
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import { headers } from 'next/headers'

// Helper to get site URL for redirects (same pattern as auth.ts)
async function getSiteUrl() {
  const headersList = await headers()
  const host = headersList.get('host') || 'localhost:3000'
  const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http'
  return `${protocol}://${host}`
}

export async function createSubscriptionCheckout(planId: PlanId) {
  const supabase = await createClient()
  const siteUrl = await getSiteUrl()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    redirect('/login?next=/subscribe')
  }

  const plan = PLANS[planId]
  if (!plan || !plan.priceId) {
    return { error: 'Invalid plan selected' }
  }

  // Check if user already has a subscription with Stripe customer
  const { data: existingSub } = await supabase
    .from('subscriptions')
    .select('stripe_customer_id')
    .eq('user_id', user.id)
    .single()

  try {
    const session = await stripe.checkout.sessions.create({
      customer: existingSub?.stripe_customer_id || undefined,
      customer_email: existingSub?.stripe_customer_id ? undefined : user.email,
      mode: 'subscription',
      payment_method_types: ['card'],
      line_items: [
        {
          price: plan.priceId,
          quantity: 1,
        },
      ],
      success_url: `${siteUrl}/dashboard?checkout=success&session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${siteUrl}/subscribe?checkout=cancelled`,
      metadata: {
        user_id: user.id, // Critical: enables webhook to identify user
        plan_id: planId,
      },
      subscription_data: {
        metadata: {
          user_id: user.id,
          plan_id: planId,
        },
      },
    })

    if (!session.url) {
      return { error: 'Failed to create checkout session' }
    }

    redirect(session.url)
  } catch (error) {
    console.error('Checkout session error:', error)
    return { error: 'Failed to create checkout session. Please try again.' }
  }
}

export async function createCreditPackCheckout(packId: CreditPackId) {
  const supabase = await createClient()
  const siteUrl = await getSiteUrl()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    redirect('/login?next=/billing')
  }

  const pack = CREDIT_PACKS[packId]
  if (!pack || !pack.priceId) {
    return { error: 'Invalid credit pack selected' }
  }

  // User must have an active subscription to buy credit packs
  const { data: subscription } = await supabase
    .from('subscriptions')
    .select('stripe_customer_id, status')
    .eq('user_id', user.id)
    .eq('status', 'active')
    .single()

  if (!subscription) {
    return { error: 'You must have an active subscription to purchase credit packs' }
  }

  try {
    const session = await stripe.checkout.sessions.create({
      customer: subscription.stripe_customer_id || undefined,
      customer_email: subscription.stripe_customer_id ? undefined : user.email,
      mode: 'payment', // One-time payment for credit pack
      payment_method_types: ['card'],
      line_items: [
        {
          price: pack.priceId,
          quantity: 1,
        },
      ],
      success_url: `${siteUrl}/billing?checkout=success&credits=${pack.credits}`,
      cancel_url: `${siteUrl}/billing?checkout=cancelled`,
      metadata: {
        user_id: user.id,
        pack_id: packId,
        credits: pack.credits.toString(),
      },
    })

    if (!session.url) {
      return { error: 'Failed to create checkout session' }
    }

    redirect(session.url)
  } catch (error) {
    console.error('Credit pack checkout error:', error)
    return { error: 'Failed to create checkout session. Please try again.' }
  }
}
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. File exists at lib/actions/checkout.ts
3. Both functions export correctly
  </verify>
  <done>Checkout Server Actions created for subscriptions and credit packs with user_id metadata</done>
</task>

<task type="auto">
  <name>Task 2: Create billing management Server Actions</name>
  <files>lib/actions/billing.ts</files>
  <action>
Create `lib/actions/billing.ts`:
```typescript
'use server'

import { stripe } from '@/lib/stripe/client'
import { PLANS, type PlanId } from '@/lib/stripe/config'
import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import { headers } from 'next/headers'

// Helper to get site URL for redirects
async function getSiteUrl() {
  const headersList = await headers()
  const host = headersList.get('host') || 'localhost:3000'
  const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http'
  return `${protocol}://${host}`
}

// Create Stripe Customer Portal session for subscription management
export async function createPortalSession() {
  const supabase = await createClient()
  const siteUrl = await getSiteUrl()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    redirect('/login')
  }

  const { data: subscription } = await supabase
    .from('subscriptions')
    .select('stripe_customer_id')
    .eq('user_id', user.id)
    .single()

  if (!subscription?.stripe_customer_id) {
    return { error: 'No subscription found. Please subscribe first.' }
  }

  try {
    const session = await stripe.billingPortal.sessions.create({
      customer: subscription.stripe_customer_id,
      return_url: `${siteUrl}/billing`,
    })

    redirect(session.url)
  } catch (error) {
    console.error('Portal session error:', error)
    return { error: 'Failed to open billing portal. Please try again.' }
  }
}

// Get user's current subscription details
export async function getSubscription() {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'Not authenticated' }
  }

  const { data: subscription, error } = await supabase
    .from('subscriptions')
    .select('*')
    .eq('user_id', user.id)
    .single()

  if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned
    console.error('Error fetching subscription:', error)
    return { error: 'Failed to fetch subscription' }
  }

  if (!subscription) {
    return { subscription: null }
  }

  // Get plan details
  const plan = PLANS[subscription.plan as PlanId]

  return {
    subscription: {
      id: subscription.id,
      plan: subscription.plan as PlanId,
      planName: plan?.name || subscription.plan,
      planFeatures: plan?.features || [],
      status: subscription.status,
      creditsRemaining: subscription.credits_remaining,
      creditsTotal: subscription.credits_total,
      overageCredits: subscription.overage_credits || 0,
      currentPeriodStart: subscription.current_period_start,
      currentPeriodEnd: subscription.current_period_end,
    },
  }
}

// Get user's credit balance (total available)
export async function getCreditBalance() {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'Not authenticated' }
  }

  const { data: subscription, error } = await supabase
    .from('subscriptions')
    .select('credits_remaining, overage_credits, status')
    .eq('user_id', user.id)
    .eq('status', 'active')
    .single()

  if (error && error.code !== 'PGRST116') {
    console.error('Error fetching credits:', error)
    return { error: 'Failed to fetch credit balance' }
  }

  if (!subscription) {
    return {
      balance: {
        subscription: 0,
        overage: 0,
        total: 0,
      },
    }
  }

  return {
    balance: {
      subscription: subscription.credits_remaining || 0,
      overage: subscription.overage_credits || 0,
      total: (subscription.credits_remaining || 0) + (subscription.overage_credits || 0),
    },
  }
}

// Get credit transaction history
export async function getCreditHistory(limit = 20) {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'Not authenticated' }
  }

  const { data: transactions, error } = await supabase
    .from('credit_transactions')
    .select('id, amount, type, description, created_at')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false })
    .limit(limit)

  if (error) {
    console.error('Error fetching credit history:', error)
    return { error: 'Failed to fetch credit history' }
  }

  return { transactions: transactions || [] }
}
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. File exists at lib/actions/billing.ts
3. All functions export correctly
  </verify>
  <done>Billing Server Actions created for portal access, subscription details, and credit balance</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- TypeScript compilation passes
- Server Actions can be imported from lib/actions/checkout.ts and lib/actions/billing.ts
</verification>

<success_criteria>
1. createSubscriptionCheckout creates Stripe Checkout session with user_id metadata
2. createCreditPackCheckout requires active subscription before purchase
3. createPortalSession redirects to Stripe Customer Portal
4. getSubscription returns current subscription with plan details
5. getCreditBalance returns combined subscription + overage credits
6. getCreditHistory returns transaction history
7. All functions handle unauthenticated users appropriately
</success_criteria>

<output>
After completion, create `.planning/phases/03-subscription-and-credits/03-03-SUMMARY.md`
</output>
