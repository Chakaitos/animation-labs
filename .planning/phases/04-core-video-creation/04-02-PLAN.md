---
phase: 04-core-video-creation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - lib/actions/video.ts
  - app/api/webhooks/video-status/route.ts
autonomous: true

must_haves:
  truths:
    - "Server Action validates credits before allowing video creation"
    - "Server Action validates file using magic bytes before upload"
    - "Logo is uploaded to Supabase Storage with user-scoped path"
    - "Video record is created with processing status"
    - "Credits are atomically deducted after video record creation"
    - "n8n webhook is triggered fire-and-forget (no await on response)"
    - "Callback endpoint updates video status idempotently"
  artifacts:
    - path: "lib/actions/video.ts"
      provides: "Video creation Server Actions"
      exports: ["createVideo"]
    - path: "app/api/webhooks/video-status/route.ts"
      provides: "n8n callback endpoint for video status updates"
      exports: ["POST"]
  key_links:
    - from: "lib/actions/video.ts"
      to: "lib/utils/file-validation.ts"
      via: "import { validateImageFile }"
      pattern: "validateImageFile"
    - from: "lib/actions/video.ts"
      to: "supabase.rpc('check_credits')"
      via: "credit validation"
      pattern: "rpc\\('check_credits'"
    - from: "lib/actions/video.ts"
      to: "supabase.rpc('deduct_credits')"
      via: "atomic credit deduction"
      pattern: "rpc\\('deduct_credits'"
    - from: "lib/actions/video.ts"
      to: "N8N_WEBHOOK_URL"
      via: "fetch (fire-and-forget)"
      pattern: "N8N_WEBHOOK_URL"
    - from: "app/api/webhooks/video-status/route.ts"
      to: "videos table"
      via: "idempotent update using webhook_id"
      pattern: "webhook_id"
---

<objective>
Create Server Actions for video creation and webhook callback endpoint for n8n status updates.

Purpose: Enable the form to submit video creation requests with proper credit validation, file upload, and n8n workflow triggering.
Output: createVideo Server Action and /api/webhooks/video-status callback endpoint.
</objective>

<execution_context>
@/Users/chakaitos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chakaitos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-video-creation/04-RESEARCH.md
@.planning/phases/03-subscription-and-credits/03-02-SUMMARY.md (webhook pattern, credit deduction)
@.planning/phases/03-subscription-and-credits/03-03-SUMMARY.md (Server Action pattern)
@lib/actions/billing.ts (Server Action pattern to follow)
@lib/utils/file-validation.ts (magic byte validation)
@lib/validations/video-schema.ts (Zod schema)
@supabase/migrations/00001_initial_schema.sql (videos table schema)
@supabase/migrations/00002_webhook_events.sql (credit functions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create video creation Server Action</name>
  <files>lib/actions/video.ts</files>
  <action>
Create lib/actions/video.ts following the established Server Action pattern from billing.ts:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { videoSchema, type VideoFormValues } from '@/lib/validations/video-schema'
import { validateImageFile } from '@/lib/utils/file-validation'
import { redirect } from 'next/navigation'
import { headers } from 'next/headers'

// Helper to get site URL for callback URL
async function getSiteUrl() {
  const headersList = await headers()
  const host = headersList.get('host') || 'localhost:3000'
  const protocol = process.env.NODE_ENV === 'production' ? 'https' : 'http'
  return `${protocol}://${host}`
}

export interface CreateVideoResult {
  success?: boolean
  videoId?: string
  error?: string
  fieldErrors?: Partial<Record<keyof VideoFormValues | 'logo', string>>
}

/**
 * Create a video from logo upload and form parameters.
 *
 * Flow:
 * 1. Authenticate user
 * 2. Validate form data with Zod
 * 3. Validate file using magic bytes
 * 4. Check user has sufficient credits
 * 5. Upload logo to Supabase Storage
 * 6. Create video record with 'processing' status
 * 7. Deduct credits atomically
 * 8. Trigger n8n webhook (fire-and-forget)
 * 9. Redirect to dashboard
 */
export async function createVideo(formData: FormData): Promise<CreateVideoResult> {
  const supabase = await createClient()
  const siteUrl = await getSiteUrl()

  // 1. Authenticate user
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    redirect('/login')
  }

  // 2. Validate form data
  const rawData = {
    brandName: formData.get('brandName'),
    duration: formData.get('duration'),
    quality: formData.get('quality'),
    style: formData.get('style'),
    creativeDirection: formData.get('creativeDirection') || '',
    primaryColor: formData.get('primaryColor'),
    secondaryColor: formData.get('secondaryColor'),
  }

  const validated = videoSchema.safeParse(rawData)
  if (!validated.success) {
    const fieldErrors: CreateVideoResult['fieldErrors'] = {}
    for (const error of validated.error.errors) {
      const field = error.path[0] as keyof VideoFormValues
      fieldErrors[field] = error.message
    }
    return { error: 'Validation failed', fieldErrors }
  }

  // 3. Validate file using magic bytes (server-side security)
  const file = formData.get('logo') as File | null
  if (!file || !(file instanceof File) || file.size === 0) {
    return { error: 'Logo file is required', fieldErrors: { logo: 'Please upload a logo' } }
  }

  const fileValidation = await validateImageFile(file)
  if (!fileValidation.valid) {
    return { error: fileValidation.error, fieldErrors: { logo: fileValidation.error } }
  }

  // 4. Check credits using RPC function
  const { data: hasCredits, error: creditCheckError } = await supabase.rpc('check_credits', {
    p_user_id: user.id,
    p_required: 1,
  })

  if (creditCheckError) {
    console.error('Credit check error:', creditCheckError)
    return { error: 'Failed to check credit balance. Please try again.' }
  }

  if (!hasCredits) {
    return { error: 'Insufficient credits. Please purchase more credits or upgrade your plan.' }
  }

  // 5. Upload logo to Supabase Storage
  // Path format: {user_id}/{uuid}.{extension} for RLS policy
  const fileExtension = file.name.split('.').pop()?.toLowerCase() || 'png'
  const fileName = `${user.id}/${crypto.randomUUID()}.${fileExtension}`

  const { data: uploadData, error: uploadError } = await supabase.storage
    .from('logos')
    .upload(fileName, file, {
      contentType: fileValidation.mimeType,
      upsert: false,
    })

  if (uploadError) {
    console.error('Upload error:', uploadError)
    return { error: 'Failed to upload logo. Please try again.' }
  }

  // Get public URL for n8n
  const { data: { publicUrl } } = supabase.storage
    .from('logos')
    .getPublicUrl(uploadData.path)

  // 6. Create video record with 'processing' status
  const { data: video, error: videoError } = await supabase
    .from('videos')
    .insert({
      user_id: user.id,
      brand_name: validated.data.brandName,
      status: 'processing',
      logo_url: publicUrl,
      duration_seconds: parseInt(validated.data.duration.replace('s', ''), 10),
      quality: validated.data.quality === 'standard' ? '720p' : validated.data.quality === 'premium' ? '1080p' : validated.data.quality,
      style: validated.data.style,
      primary_color: validated.data.primaryColor,
      secondary_color: validated.data.secondaryColor,
      creative_direction: validated.data.creativeDirection || null,
      credits_used: 1,
    })
    .select('id')
    .single()

  if (videoError) {
    console.error('Video record error:', videoError)
    // Clean up uploaded file on failure
    await supabase.storage.from('logos').remove([uploadData.path])
    return { error: 'Failed to create video. Please try again.' }
  }

  // 7. Deduct credits atomically
  const { data: deductSuccess, error: deductError } = await supabase.rpc('deduct_credits', {
    p_user_id: user.id,
    p_video_id: video.id,
    p_credits: 1,
    p_description: `Video: ${validated.data.brandName}`,
  })

  if (deductError || !deductSuccess) {
    console.error('Credit deduction error:', deductError)
    // Rollback: delete video record and uploaded file
    await supabase.from('videos').delete().eq('id', video.id)
    await supabase.storage.from('logos').remove([uploadData.path])
    return { error: 'Failed to deduct credits. Please try again.' }
  }

  // 8. Trigger n8n webhook (fire-and-forget)
  // IMPORTANT: Do NOT await this - n8n will process asynchronously
  const webhookUrl = process.env.N8N_WEBHOOK_URL
  const webhookSecret = process.env.N8N_WEBHOOK_SECRET

  if (webhookUrl) {
    fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(webhookSecret && { 'X-Webhook-Secret': webhookSecret }),
      },
      body: JSON.stringify({
        videoId: video.id,
        logoUrl: publicUrl,
        brandName: validated.data.brandName,
        duration: validated.data.duration,
        quality: validated.data.quality,
        style: validated.data.style,
        primaryColor: validated.data.primaryColor,
        secondaryColor: validated.data.secondaryColor,
        creativeDirection: validated.data.creativeDirection || null,
        callbackUrl: `${siteUrl}/api/webhooks/video-status`,
        webhookSecret: webhookSecret || null,
      }),
    }).catch((err) => {
      // Log but don't fail - video is already created and credits deducted
      console.error('n8n webhook trigger failed:', err)
    })
  } else {
    console.warn('N8N_WEBHOOK_URL not configured - video will remain in processing status')
  }

  // 9. Success - return videoId (form will redirect)
  return { success: true, videoId: video.id }
}
```

IMPORTANT patterns:
- Fire-and-forget webhook: Do NOT await the fetch call to n8n
- Rollback on failure: Clean up storage and video record if credit deduction fails
- Magic byte validation: Use validateImageFile before trusting the file
- User-scoped storage path: `{user_id}/{uuid}.extension` for RLS
  </action>
  <verify>
  - `npx tsc --noEmit` passes
  - File exports createVideo function
  - Function uses validateImageFile for security
  - Function calls supabase.rpc('check_credits') and supabase.rpc('deduct_credits')
  - Webhook fetch is NOT awaited (fire-and-forget pattern)
  </verify>
  <done>Video creation Server Action created with credit validation, file upload, atomic credit deduction, and fire-and-forget n8n webhook trigger.</done>
</task>

<task type="auto">
  <name>Task 2: Create webhook callback endpoint for n8n status updates</name>
  <files>app/api/webhooks/video-status/route.ts</files>
  <action>
Create app/api/webhooks/video-status/route.ts for n8n to call back with video status:

```typescript
import { createClient } from '@supabase/supabase-js'
import { headers } from 'next/headers'
import { NextResponse } from 'next/server'

// Use service role client for webhook processing (bypasses RLS)
function getServiceClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY

  if (!supabaseUrl || !serviceRoleKey) {
    throw new Error('Missing Supabase environment variables')
  }

  return createClient(supabaseUrl, serviceRoleKey, {
    auth: { persistSession: false },
  })
}

// Expected payload from n8n
interface VideoStatusPayload {
  videoId: string
  status: 'processing' | 'completed' | 'failed'
  videoUrl?: string       // URL to completed video
  thumbnailUrl?: string   // URL to video thumbnail
  errorMessage?: string   // Error message if failed
  n8nExecutionId?: string // n8n execution ID for debugging
  metadata?: Record<string, unknown> // Additional metadata from n8n
}

export async function POST(request: Request) {
  const headersList = await headers()

  // Verify webhook secret
  const secret = headersList.get('x-webhook-secret')
  const expectedSecret = process.env.N8N_WEBHOOK_SECRET

  if (expectedSecret && secret !== expectedSecret) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    )
  }

  // Get unique webhook ID for idempotency (n8n should send this)
  const webhookId = headersList.get('x-webhook-id') || headersList.get('x-n8n-execution-id')

  let body: VideoStatusPayload
  try {
    body = await request.json()
  } catch {
    return NextResponse.json(
      { error: 'Invalid JSON body' },
      { status: 400 }
    )
  }

  // Validate required fields
  const { videoId, status, videoUrl, thumbnailUrl, errorMessage, n8nExecutionId, metadata } = body

  if (!videoId || !status) {
    return NextResponse.json(
      { error: 'Missing required fields: videoId, status' },
      { status: 400 }
    )
  }

  if (!['processing', 'completed', 'failed'].includes(status)) {
    return NextResponse.json(
      { error: 'Invalid status. Must be: processing, completed, or failed' },
      { status: 400 }
    )
  }

  const supabase = getServiceClient()

  // Build update object
  const updateData: Record<string, unknown> = {
    status,
    updated_at: new Date().toISOString(),
  }

  if (status === 'completed') {
    if (videoUrl) updateData.video_url = videoUrl
    if (thumbnailUrl) updateData.thumbnail_url = thumbnailUrl
  }

  if (status === 'failed' && errorMessage) {
    updateData.error_message = errorMessage
  }

  if (n8nExecutionId) {
    updateData.n8n_execution_id = n8nExecutionId
  }

  if (metadata) {
    updateData.metadata = metadata
  }

  // Idempotent update: Only update if not already processed with this webhook ID
  // If no webhook ID provided, update regardless (less safe but works)
  let query = supabase
    .from('videos')
    .update(updateData)
    .eq('id', videoId)

  // If we have a webhook ID, use it for idempotency
  // Only update if n8n_execution_id is null OR matches the incoming ID
  if (webhookId) {
    query = query.or(`n8n_execution_id.is.null,n8n_execution_id.eq.${webhookId}`)
  }

  const { data, error } = await query.select('id, status')

  if (error) {
    console.error('Video status update error:', error)
    return NextResponse.json(
      { error: 'Database error' },
      { status: 500 }
    )
  }

  // If no rows updated, either video doesn't exist or already processed
  if (!data || data.length === 0) {
    // Check if video exists
    const { data: existing } = await supabase
      .from('videos')
      .select('id, status, n8n_execution_id')
      .eq('id', videoId)
      .single()

    if (!existing) {
      return NextResponse.json(
        { error: 'Video not found' },
        { status: 404 }
      )
    }

    // Already processed (idempotent response)
    return NextResponse.json({
      message: 'Already processed',
      videoId: existing.id,
      status: existing.status,
    })
  }

  return NextResponse.json({
    success: true,
    videoId: data[0].id,
    status: data[0].status,
  })
}
```

IMPORTANT patterns:
- Service role client: Bypasses RLS for webhook processing
- Idempotency: Uses n8n_execution_id or x-webhook-id to prevent duplicate processing
- Graceful handling: Returns 200 for already-processed webhooks (no retry needed)
- Webhook secret verification: Validates X-Webhook-Secret header
  </action>
  <verify>
  - `npx tsc --noEmit` passes
  - File exports POST function
  - Endpoint verifies X-Webhook-Secret header
  - Endpoint updates video status based on payload
  - Endpoint handles idempotency (returns 200 for already-processed)
  </verify>
  <done>Webhook callback endpoint created for n8n to update video status with idempotency protection.</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - TypeScript compiles without errors
2. Run `npm run build` - build succeeds
3. Check lib/actions/video.ts:
   - Exports createVideo
   - Uses validateImageFile from lib/utils/file-validation
   - Calls check_credits and deduct_credits RPC functions
   - Has fire-and-forget webhook trigger (no await on fetch)
4. Check app/api/webhooks/video-status/route.ts:
   - Exports POST
   - Verifies webhook secret
   - Updates video status
   - Handles idempotency
</verification>

<success_criteria>
- createVideo Server Action validates form data, file, and credits before processing
- Logo is uploaded to Supabase Storage with path {user_id}/{uuid}.{ext}
- Video record is created with status 'processing'
- Credits are deducted atomically via RPC
- n8n webhook is triggered without blocking (fire-and-forget)
- Callback endpoint updates video status with proper security and idempotency
- TypeScript compiles and build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-video-creation/04-02-SUMMARY.md`
</output>
